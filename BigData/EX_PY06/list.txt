[PY06]
## 목차
 ##
  #
    *
    1.

## 데이터 종류
  데이터 타입 : int, float, str
  타입 변경 : 형변환, 타입캐스팅, 캐스팅.

  프리미티브 데이터 타입 : int float str 
  콜렉션 타입 : 리스트, 튜플, 딕셔너리, 셋(set)
    -> 각 프리미티브 / 콜렉션 끼리 형변환은 가능하다,  But 이 2가지 간의 형변환은 안댐.


## 메모리할당
  수식
  글자
  논리 
  3가지로 나누어놓았다. 각자 할당 메모리가 다르기 때문에. 파이썬에서는 메모리 할당을 직접 다루지 않아 신경쓰지 않지만,
  다른 언어, 특히 C에서는 핸들링할 경우가 많아 3가지 타입에서 메모리 할당을 신경써야한다.
   자료구조, 알고리즘... 뭐라고 하셧엇음. 못들었다.

## 내장함수
  # print()
    정의 : 모니터 즉, 콘솔/터미널에 출력하는 함수
    * 기본 사용법
      print("글자")
      print(변수)
        -> 여러 개의 경우
        print(변수, 변수, 변수)
        print(num1, "+", num2, "=", num1+num2)처럼 변수, "문자열", 변수, "문자열" 줄줄이 나열도 가능.
        더 편한 방식은 아래 f-string 참고.

    * 띄워쓰기
    print(a, b, c)   출력결과 : a b c
    print(a+b+c)     출력결과 : abc     *모두 str 이어야함. int와 str 변수 함께 사용 x

    * f-string
      형식 : f'     '
      문자열 사이에 변수를 {}에 넣어 출력되도록 한다.
      ex. print(f"{num1} + {num2} = {num1+num2}")
      
    * print 함수의 매개변수
      매개변수(parameter) : 함수 코드 실행 시에 필요한 데이터를 명시해 놓은 것 (서식,형식,갯수의 틀 개념(?))
      1. sep 매개변수 : 구분자 의미, 여러 개의 데이터를 보기 좋게 출력되도록 구분해주는 변수
          기본세팅 : str  |  None : " "
          ex. print("010","1111","2222", sep=" * ")  출력 결과 : 010 * 1111 * 2222
          ,로 구분된 3개의 문자열 사이에 sep이 " * "로 되어있기 때문.
      2. end 매개변수 : 출력 데이터의 마지막 부분에 줄바꿈 문자를 추가해놓은 변수
          기본세팅 : str  |  None : "\n"
  # 내장함수 input()

  # 내장함수 range()
    수의 범위를 만들어내는 내장함수
    range(시작숫자, 끝숫자+1, 간격) -> 정수만 가능.
  
  # 


## 서식지정
 화면 출력 글자를 만들곡 그 글자 안에 특정 결과를 출력하는 형식
 글자 내부에 값의 형식을 미리 지정
  %d , %i  부호가 있는 10진수, 정수     |   %c 단일 문자 (알파벳, 정수 등)
  %s  문자열                           |   %f , %u  부호가 있는 10진수 실수, 부호가 없는 10진수 실수
  %o | %x |  %X |  %e 등등 

    ex. print('num1 + num2 = %d' %(num1+num2))

    

## file _ Day02 _ print03

## 연산자 _ Day02 _ op

## 메모리
  적고 비싸니까 잘 써보자~ 해서
  메모리를 4등분해놓았다. 코드/데이터/힙/스택 영역으로.
  
## 문자열 _ Day03 

## 시퀀스 데이터
  원소들이 순서가 있고 반복 가능한 데이터 타입
   - 특징
    1. 슬라이싱, 인덱싱
    2. 인덱스
    3. 종류로 리스트(수정x), 튜플(수정 o), 문자열(수정x)이 있다.

    + 반복 가능한 데이터 타입
     시퀀스 데이터 타입 포함
     내부에 next ()를 사용해서 다음 원소, 다음 원소 ... 추출

## 콜렉션 타입
  # list
  # tuple

    - 메서드
  # Dictionary (딕셔너리)
    * 정의 : 
    * 형식 : a = {"Key1":"Values", "Key2" : "Values2"} 
      -> key와 value에 데이터 타입은 상관없다.
      -> Value에 리스트. 튜플 다 가능.

    * 메서드 (Day07_dict_method 참고.)
      1. keys : 값을 읽어오는 메서드
        키에 해당하는 values가 없으면  default값 반환
        없는 키를 소환할 시 에러 발생!
      2. values 
      3. items

      4. update : 수정 및 추가 메서드
        - dict[key] = values      => 해당 식으로 기본적으로 추가 및 수정 둘 다 가능. 
        - dict.update(key=values)  => 이때 키가 str이어도 ""(따옴표)를 붙이지 않는다! 업데이트 하는데, 요런 키에 values가 저런걸로 넣을거야!
        - dict.update{{key1:values1, key2:values2}} => 업데이트하는데, () 안에 아예 다른 딕셔너리를 미리 구상. 이걸 통으로 업데이트!
        
      # Dict : 데이터의 의미를 함께 저장하는 자료형
      # - 형태 : {키1:값, 키2:값, 키3:값, ... 키n: 값}
      # - 키는 중복x, 값은 중복o
      # - 데이터 분석 시 파일 데이터 가져올 때 많이 사용한다.

      # 



      ## [Dict 생성]
      data = {}

      # 값 출력
      dict[key]



      ## [Dict 원소/요소 변경] : 변수명[키] = 새로운 값
      dict[key] = value
      ##- del 변수명[키] 또는 del(변수명[키])
      del dict[key]
      """
      # 키와 값에는 다양한 타입이 들어올 수 있다. 키를 여러개의 정보를 합쳐서 사용하는 경우 Tuple타입을 사용할 수 있고,
          person = {"age" : 20, ("홍길동", 2000):100} => 문자열, 정수, 튜플 들어감.
      persen 이라는 공통분모에서 p1~p4까지 리스트로 묶은 후 p1~p4라는 각 딕셔너리를 만들 수 있다.
      persons3 = {("홍길동", 20) :{"job": "학생"})
      p1 = {"name":"홍길동", "age" : 20, "job":"학생"}
      p2 = {"name":"마징가", "age" : 100, "job":"영웅"}
      p3 = {"name":"베트맨", "age" : 98, "job":"박쥐"}
      p4 = {"name":"홍길동", "age" : 11, "job":"학생"}
      persons=[p1,p2,p3,p4]
      print(persons[0]['name'])
      print(persons["name"])
      이때 값을 읽어오기 위해서는 [][]를 통해 정보에 2번 진입해줘야한다.

      또한, 이때 동명이인이 발생할 수 있으니 중복되면 안되는 키 설정을 위해 고유정보를 키로 이중 딕셔너리형도 가능하다.
      persons2={
          20: {"name":"홍길동", "job":"학생"},
          100: {"name":"마징가", "job":"영웅"},
          98 : {"name":"베트맨", "job":"박쥐"},
          11 : {"name":"홍길동", "job":"학생"}
              }
      중복되지 않는 키, 나이를 이용해 다른 정보를 부여한다.

      """
        
        





  # Set
    중복, 순서가 없는 데이터 집합
    ## 덧셈연산 ==> 메서드 사용, 합집합
    # print(d1+d2) 
    # 미지원.
    print(d1.union(d2) , d1 | d2)
    # 양쪽이 동일한 효과


    ## 공통 원소 ==> 교집합
    print(d1.intersection(d2) , d1 & d2)


    ## 집합에서 공통 원소 제외한 나머지 ==> 차집함
    print(d1.difference(d1), d2-d1)
      


# 메서드

# day05 for 2
 [실습] 원소/요소의 인덱스와 값을 함께 가져오기
 enumerate()내장함수
 - 전달된 반복가능한 객체에서 원소당 번호를 부여해서 튜플로 묶어줌
 - 원소의 인덱스 정보가 필요한 경우 사용